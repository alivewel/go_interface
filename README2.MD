### [Где лучше размещать интерфейс?](https://www.youtube.com/watch?v=eYHCCht8eX4)

Небольший спойлер: **Интерфейсы лучше размещать в месте их использования.**

Рекомендации по использованию интерфейсов:
1. **Интерфейсы должны быть минималистичными.**
2. **Интерфейс ничего не должен знать о типах, которые его реализуют.**

Рассмотрим пример некого сервиса.
В этом сервисе нас интересует два слоя: `storage` и `handlers`. В слое `storage` есть пакет `users`, в котором указаны методы для различных БД: `Postgres`, `Redis`, `MySQL` и т.д.

#### Структура проекта

- **`some_service/`**: Главная директория сервиса.
  - **`handlers/`**: Папка для хэндлеров (обработчиков).
    - **`userinfo/`**: Подпапка для работы с информацией о пользователях.
  - **`lib/`**: Библиотеки и вспомогательные модули.
  - **`services/`**: Логика и бизнес-слой сервиса.
  - **`storage/`**: Хранилище данных.
    - **`users/`**: Папка для управления пользователями.
      - Подпапки для различных реализаций хранения, такие как:
        - **`cache/`**
        - **`mysql/`**
        - **`postgres/`**
        - **`redis/`**
      - **`users.go`**: Файл с реализацией интерфейсов для работы с пользователями. 

Чтобы не зависеть от типа реализации мы решили описать общий интерфейс, который называется `Storage`. В общем интерфейсе содержаться все методы, которые необходимы для взаимодействия со всеми БД.

```go
package users

type User struct {
    ID   int
    Name string
    Age  int
}

type Storage interface {
    Users() ([]User, error)
    UsersByAge(age int) ([]User, error)
    User(id int) (User, error)
    Create(user User) error
    Update(user User) error
    Delete(id int) error
    // другие методы...
}
```

Кажется, что мы соблюдаем правило №2 - интерфейс ничего не должен знать о типах, которые его реализуют, но это не совсем так.

Мы используем данный интерфейс в слой `handlers`. В частности, в нем у нас есть функция `New`, которая принимает интерфейс `Storage`, в котором множество методов.

```go
package userinfo

import (
	"context"
	"fmt"
	"service/handlers"
	"service/storage/users"
)

func New(userRepo users.Storage) handlers.Handler {
	return func(ctx context.Context) error {
		// Получение UID из запроса
		uid := 1
		user, err := userRepo.User(uid)
		if err != nil {
			// Обработка ошибки
			return fmt.Errorf("failed to get user: %w", err)
		}
		fmt.Printf("User: %+v\n", user)
		return nil
	}
}

```

Чтобы не тащить за собой огромный интерфейс с кучей методов, мы можем описать интерфейс в месте его использования, прямо в этом хендлере. В этом хендлере мы используем один единственный метод `User()`. Это значит, что мы можем создать здесь интерфейс, в котором будет необходимый метод. Создадим интерфейс `UserProvider`, в котором будет метод `User()`.

```go
package userinfo

import (
	"context"
	"fmt"
	"service/handlers"
	"service/storage/users"
)

type UserProvider interface {
    User(int) (users.User, error)
}

func New(userProvider UserProvider) handlers.Handler {
	return func(ctx context.Context) error {
		// Получение UID из запроса
		uid := 1
		user, err := userProvider.User(uid)
		if err != nil {
			// Обработка ошибки
			return fmt.Errorf("failed to get user: %w", err)
		}
		fmt.Printf("User: %+v\n", user)
		return nil
	}
}
```

#### Что нам это дает?

- **Минималистичный интерфейс**: В нашем методе нет намека на какую-либо базу данных. Метод `User()` просто каким-то образом возвращает пользователя.
- **Уменьшение связности**: Пакет `handlers` никак не зависит от пакета `storage`. Связность компонентов системы должна быть как можно меньше.
- **Понятность кода**: Мы сделали ясными ожидания и потребности разных частей системы. При чтении кода в пакете `handlers`, мы видим, какой интерфейс ожидает функция, и этот интерфейс описан в этом же пакете. При использовании большого интерфейса `Storage`, мы видим, что у него много методов, и не сразу понятно, для чего они нужны. Также, чтобы прочитать описание интерфейса, нужно перейти в другой пакет.
- **Гибкость системы**: Допустим, мы хотим передать вместо с сущностью `Postgres` сущность `Redis`. Чтобы соответствовать данному интерфейсу, нам придется реализовать все его методы, даже если они не используются.
- **Тестирование**: При написании юнит-тестов для тестирования логики функции нам необходимо изолироваться от какой-либо базы данных. Mock'и позволяют нам этого добиться. Поскольку интерфейс описан в пакете `handlers`, то и сгенерировать mock мы можем в этом же пакете.

#### Минусы подхода

- Дублирование описания интерфейса по всем частям сервиса. Если мы захотим изменить сигнатуры методов, то нам придется это сделать во всех частях системы. Если бы у нас был один общий интерфейс, достаточно было бы изменить его только в одном месте.

- Новичкам из других языков не всегда понятен такой подход, который связан с утиной типизацией и неявной имплементацией интерфейсов в Go.

#### Принципы SOLID

Также хочется отметить, что придерживаясь такого подхода, мы соответствуем следующим принципам SOLID:

- **Принцип разделения интерфейсов (I)**: **Программные сущности не должны зависеть от методов, которые они не используют.**  
Разделение одного большого интерфейса на несколько мелких.

- **Принцип инверсии зависимостей (D)**: **Модули верхних уровней не должны зависеть от модулей нижних уровней. Оба типа модулей должны зависеть от абстракций. Абстракции не должны зависеть от деталей, детали должны зависеть от абстракций.**  
Создание абстракций, которые позволяют модулям взаимодействовать без прямой зависимости друг от друга.

### Цитата про необходимость разделения одного большого интерфейса на несколько мелких из статьи про постулаты Go ([Go proverbs](https://habr.com/ru/articles/272383/))

#### Чем больше интерфейс, тем слабее абстракция (The bigger the interface, the weaker the abstraction)

Новички в Go, особенно пришедшие с Java, часто считают, что интерфейсы должны быть большими и содержать много методов. Также часто их смущает неявное удовлетворение интерфейсов. Но самое важное в интерфейсах не это, а культура вокруг них, которая отражена в этом постулате. Чем меньше интерфейс, тем более он полезен. Пайк шутит, что три самых полезных интерфейса, которые он написал — `io.Reader`, `io.Writer` и `interface{}` — на троих в среднем имеют 0.666 метода.
